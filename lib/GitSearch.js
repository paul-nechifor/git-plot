// Generated by CoffeeScript 1.7.1
var GitSearch, findit, git;

git = require('nodegit');

findit = require('findit');

String.prototype.endsWith = function(suffix) {
  return this.indexOf(suffix, this.length - suffix.length) !== -1;
};

GitSearch = (function() {
  function GitSearch(searchDir, authorRegex, emailRegex) {
    this.searchDir = searchDir != null ? searchDir : '/home';
    this.authorRegex = authorRegex != null ? authorRegex : /.*/;
    if (emailRegex == null) {
      emailRegex = /.*/;
    }
    this.commits = [];
    this.repoDirs = [];
    this.preventGC = [];
    this.fields = [];
  }

  GitSearch.prototype.search = function(cb) {
    return this.findRepos((function(_this) {
      return function(err) {
        if (err) {
          return cb(err);
        }
        return _this.pushReposCommits(function() {
          var field, keep, _i, _len, _ref;
          _this.commits.sort(function(a, b) {
            return a.date - b.date;
          });
          if (_this.fields.length === 0) {
            return cb();
          }
          keep = {};
          _ref = _this.fields;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            field = _ref[_i];
            keep[field] = true;
          }
          _this.commits.map(function(c) {
            var key;
            for (key in c) {
              if (!keep[key]) {
                delete c[key];
              }
            }
            return c;
          });
          return cb();
        });
      };
    })(this));
  };

  GitSearch.prototype.findRepos = function(cb) {
    var finder;
    finder = findit(this.searchDir);
    finder.on('directory', (function(_this) {
      return function(dir, stat, stop) {
        if (dir.endsWith('/.git')) {
          stop();
          return _this.repoDirs.push(dir);
        }
      };
    })(this));
    return finder.on('end', function() {
      return cb();
    });
  };

  GitSearch.prototype.pushReposCommits = function(cb) {
    var i, next;
    i = 0;
    next = (function(_this) {
      return function() {
        if (i >= _this.repoDirs.length) {
          return cb();
        }
        return _this.pushRepoCommits(_this.repoDirs[i], function(err) {
          if (err) {
            throw err;
          }
          i++;
          return next();
        });
      };
    })(this);
    return next();
  };

  GitSearch.prototype.pushRepoCommits = function(repoDir, cb) {
    return git.Repo.open(repoDir, (function(_this) {
      return function(err, repo) {
        if (err) {
          return cb(err);
        }
        return repo.getMaster(function(err, branch) {
          if (branch) {
            return _this.pushBranchCommits(branch, cb);
          } else {
            return cb();
          }
        });
      };
    })(this));
  };

  GitSearch.prototype.pushBranchCommits = function(branch, cb) {
    var herstory, ret, returned;
    returned = false;
    ret = function(err) {
      if (returned) {
        return;
      }
      return cb(err);
    };
    herstory = branch.history();
    herstory.on('commit', (function(_this) {
      return function(commit) {
        return _this.processCommit(commit, function(err, commitInfo) {
          if (err) {
            ret(err);
          }
          if (commitInfo) {
            return _this.commits.push(commitInfo);
          }
        });
      };
    })(this));
    herstory.on('end', function() {
      return ret();
    });
    return herstory.start();
  };

  GitSearch.prototype.processCommit = function(commit, cb) {
    var commitInfo;
    commitInfo = {
      sha: commit.sha(),
      date: commit.date().getTime(),
      author: commit.author().name(),
      email: commit.author().email(),
      message: commit.message().split('\n')[0].trim(),
      added: 0,
      deleted: 0
    };
    if (!commitInfo.author.match(this.authorRegex)) {
      return cb();
    }
    if (!commitInfo.email.match(this.emailRegex)) {
      return cb();
    }
    return this.setChanges(commit, commitInfo, function(err) {
      if (err) {
        return cb(err);
      }
      return cb(null, commitInfo);
    });
  };

  GitSearch.prototype.setChanges = function(commit, commitInfo, cb) {
    return commit.getDiff((function(_this) {
      return function(err, difflists) {
        var difflist, i, patch, patches, stats, _i, _j, _len, _len1;
        if (err) {
          return cb(err);
        }
        for (_i = 0, _len = difflists.length; _i < _len; _i++) {
          difflist = difflists[_i];
          if (difflist.size() === 0) {
            continue;
          }
          patches = (function() {
            var _j, _ref, _results;
            _results = [];
            for (i = _j = 0, _ref = difflist.size() - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
              _results.push(difflist.patch(i).patch);
            }
            return _results;
          })();
          for (_j = 0, _len1 = patches.length; _j < _len1; _j++) {
            patch = patches[_j];
            _this.preventGC.push(patch);
            stats = patch.stats();
            commitInfo.added += stats.total_additions;
            commitInfo.deleted += stats.total_deletions;
          }
        }
        return cb();
      };
    })(this));
  };

  return GitSearch;

})();

module.exports = GitSearch;
